---
title: Java Basic - Những điều cần biết
date: 2022-07-05 23:10:34
permalink: /pages/424d66/
categories:
  - Java
  - basic
tags:
  - 
author: 
  name: vanhung4499
  link: https://github.com/vanhung4499
---

::: tip Tóm tắt
Bài viết này chủ yếu tóm tắt những kiến ​​thức cơ bản của Java.
:::

[[toc]]

## Kiểu dữ liệu (Data Types)

Trong Java có 2 kiểu dữ liệu có sẵn

### Kiểu dữ liệu nguyên thuỷ (Primitive Data Types)

Bao gồm 8 kiểu cơ bản:

| Data Type | Default Value | Size (bit) |
| :-------: | :-----------: | :--------: |
|  boolean  |     false     |     1      |
|   byte    |       0       |     8      |
|   char    |   '\u0000'    |     16     |
|   short   |       0       |     16     |
|    int    |       0       |     32     |
|   float   |     0.0f      |     32     |
|   long    |      0L       |     64     |
|  double   |     0.0d      |     64     |

Các kiểu dữ liệu nguyên thuỷ có các kiểu Wrapper tương ứng, và việc phân định giữa các kiểu cơ bản và kiểu đóng gói tương ứng của chúng được thực hiện bằng cách sử dụng **autoboxing (boxing)** và **unboxing**.

```java
Integer x = 2;     // boxing
int y = x;         // unboxing
```

### Kiểu dữ liệu tham chiếu (Non-Primitive/Reference Data type)

Kiểu dữ liệu tham chiếu Reference Data Types sẽ chứa địa chỉ bộ nhớ của biến vì kiểu tham chiếu không lưu giá trị của biến trong bộ nhớ một cách trực tiếp. Ví dụ như String, Object, Array, ... 

### Buffer Pool

Sự khác biệt giữa **new Integer(123)** và **Integer.valueOf(123)** là:
  - new Integer(123) tạo một đối tượng mới mỗi lần gọi
  - Integer.valueOf(123) sẽ sử dụng đối tượng trong buffer pool và nhiều yêu cầu sẽ nhận được một tham chiếu đến cùng một đối tượng. 

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
```

Việc triển khai phương thức valueOf () tương đối đơn giản, tức là trước tiên hãy xác định xem giá trị có nằm trong bộ nhớ cache hay không, nếu có thì trả về trực tiếp nội dung của bộ nhớ cache. 

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

Trong Java 8, kích thước của vùng đệm số nguyên là -128 -> 127 theo mặc định.

```java
static final int low = -128;
static final int high;
static final Integer cache[];

static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
        sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
    if (integerCacheHighPropValue != null) {
        try {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        } catch( NumberFormatException nfe) {
            // If the property cannot be parsed into an int, ignore it.
        }
    }
    high = h;

    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k < cache.length; k++)
        cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high >= 127;
}
```

Trình biên dịch gọi phương thức valueOf() **trong quá trình autoboxing kiểu nguyên thủy**, vì vậy nhiều đối tượng Integer được tạo bằng cách sử dụng autoboxing và có cùng giá trị sẽ tham chiếu đến cùng một đối tượng. 

```java
Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
```

Các buffer pool tương ứng với các kiểu cơ bản như sau: 
  - boolean: true or false 
  - byte: -128 -> 127
  - short: -128 -> 127
  - int:  -128 -> 127 
  - char:  \u0000 -> \u007F

Khi sử dụng các kiểu wrapper tương ứng với các kiểu nguyên thuỷ này, các đối tượng trong buffer pool có thể được sử dụng trực tiếp.

Nếu ngoài phạm vi buffer pool:

```java
Integer m = 323;
Integer n = 323;
System.out.println(m == n); // false
```

## String

### Tổng quan

String được khai báo **final** nên không thể kế thừa.

Dữ liệu trong một String được lưu trữ trong một mảng char, được khai báo **final**, có nghĩa là sau khi mảng giá trị được khởi tạo, không có mảng nào khác có thể được tham chiếu. Và không có phương thức nào để thay đổi mảng giá trị bên trong String, vì vậy String có là bất biến (**Immutable**). 

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
```

### Ưu điểm của tính bất biến

1. Caching Hashcode

Hashcode của String thường được sử dụng, ví dụ trong HashMap hoặc HashSet. String bất biến khiến hash code cũng bất biến, không cần phải tính lại, vì vậy chỉ cần một lần tính toán.

2. Yêu cầu cho String Pool

Nếu một đối tượng String đã được tạo, một tham chiếu sẽ được lấy từ String Pool. Chỉ có thể sử dụng String Pool nếu String là bất biến.

![](/img/java/string-pool.jpeg)

3. Bảo mật

String thường được sử dụng như một tham số và tính bất biến của String đảm bảo rằng tham số là bất biến. Ví dụ: trong trường hợp tham số kết nối mạng, nếu String có thể thay đổi, thì trong quá trình kết nối mạng, String sẽ bị thay đổi và bên thay đổi String nghĩ rằng nó hiện đã được kết nối với một máy chủ khác, nhưng thực tế tình hình không nhất thiết phải như vậy.

4. Thread-Safety

Vì không thể thay đổi các đối tượng bất biến, chúng có thể được chia sẻ giữa nhiều luồng một cách tự do. Điều này loại bỏ các yêu cầu của việc thực hiện đồng bộ hóa.

[Program Creek : Why String is immutable in Java?](https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/)

### String, StringBuffer và StringBuilder

1. Tính biến đổi

   - String là bất biến (**immutable**)
   - StringBuffer và StringBuilder có thể thay đổi (**mutable**)

2. Thread-Safety

- String là bất biến, do đó an toàn cho 
- StringBuilder không an toàn cho thread
- StringBuffer an toàn cho thread

Nếu ứng dụng chỉ có một luồng, StringBuilder sẽ hiệu quả hơn StringBuffer.

[StackOverflow : String, StringBuffer, and StringBuilder](https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder)

### String.intern()

Sử dụng **String.intern()** để đảm bảo rằng các biến String có cùng giá trị tham chiếu đến cùng một đối tượng bộ nhớ.

Trong ví dụ sau, s1 và s2 sử dụng new String() để tạo hai đối tượng khác nhau, trong khi s3 lấy một tham chiếu đối tượng thông qua phương thức s1.intern(). intern() trước tiên đặt đối tượng được tham chiếu bởi s1 vào String Pool, và sau đó trả về tham chiếu đối tượng. Vì vậy, s3 và s1 tham chiếu đến cùng một đối tượng String Pool.

```java
String s1 = new String("aaa");
String s2 = new String("aaa");
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
System.out.println(s1.intern() == s3);  // true
```

Nếu một biến String được khởi tạo ở dạng "bbb" bằng cách sử dụng dấu ngoặc kép, đối tượng mới được tạo sẽ tự động được đặt trong String Pool.

```java
String s4 = "bbb";
String s5 = "bbb";
System.out.println(s4 == s5);  // true
```

## Operation

### Truyền tham số (Parameter Passing)


Java luôn luôn truyền tham số theo giá trị (**pass by value**), không phải theo tham chiếu (**pass by reference**).

Trong đoạn code sau, khai báo Dog dog, dog thực ra là một con trỏ lưu địa chỉ của đối tượng. Khi truyền một tham số cho một phương thức, về cơ bản bạn đang truyền địa chỉ của đối tượng theo giá trị. Do đó, nếu đối tượng được tham chiếu bị thay đổi trong phương thức, thì hai con trỏ đang trỏ đến hai đối tượng hoàn toàn khác nhau tại thời điểm này và việc một bên thay đổi giá trị của đối tượng sẽ không ảnh hưởng đến bên kia.

```java
public class Dog {
    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }

    void setName(String name) {
        this.name = name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
```

```java
public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog("B");
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
```

Tuy nhiên, nếu bạn thay đổi giá trị thuộc tính của đối tượng trong phương thức, giá trị thuộc tính của đối tượng ban đầu sẽ bị thay đổi vì nội dung được trỏ đến bởi cùng một địa chỉ sẽ bị thay đổi. 

```java
class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName("B");
    }
}
```

[StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?](https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value)

### Float và Double


**1.1** có kiểu mặc định là **double** và **1.1** không thể được gán trực tiếp cho một biến **float** vì nó là một **downcasting**. Java không thể thực hiện **downcasting** một cách ngầm định, vì điều này sẽ làm giảm độ chính xác. 

```java
// float f = 1.1;
```

Khai báo biến kiểu float có giá trị **1.1f**.

```java
float f = 1.1f;
```

### Ép kiểu ngầm định (Implicitly Typecasting)


Bởi vì số **1** thuộc kiểu int, int lớn hơn short, java không ngầm định ép kiểu int thành short để thực hiện phép tính như sau: 

```java
short s1 = 1;
// s1 = s1 + 1; // error
```

Nhưng nếu dùng toán tử (**operator**) **+=** thì mặc định java sẽ thực hiện ép kiểu ngầm định

```
s1 += 1;
```

Câu lệnh trên tương đương với việc dự đoán kiểu dữ liệu của kết quả trong phép tính s1 + 1:

```java
s1 = (short) (s1 + 1);
```

[StackOverflow : Why don't Java's +=, -=, *=, /= compound assignment operators require casting?](https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting)

### switch

Kể từ Java 7, các biến String có thể được sử dụng trong lệnh switch

```java
String s = "a";
switch (s) {
    case "a":
        System.out.println("aaa");
        break;
    case "b":
        System.out.println("bbb");
        break;
}
```

switch không hỗ trợ kiểu long, bởi vì thiết kế ban đầu của switch là thực hiện dự đoán tương đương trên một số giá trị duy nhất, long quá lớn.

```
// long x = 111;
// switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }
```

[Why can't your switch statement data type be long, Java?](https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java)

## Kế thừa

### Phạm vi truy cập (Access Modifier)

Phạm vi truy cập (access modifier) là xác định độ truy cập phạm vi vào dữ liệu của các thuộc tính, phương thức hoặc class.

Có 4 loại Access Modifier trong Java: private, protected, public và default.
  - **private**: chỉ cho phép truy cập nội bộ của một class
  - **default**: phạm vị mặc định, phạm vi truy cập chỉ nằm trong nội bộ package
  - **protected**: phạm vi truy cập có thể từ trong và ngoài package, nhưng phải thông qua tính kế thừa. Lớp con có thể truy cập các thành phần của lớp cha.
  - **public**: phạm vi truy cập rộng, có thể truy cập bất cứ đâu

Module được thiết kế tốt sẽ ẩn tất cả các chi tiết, tách biệt rõ ràng API của nó khỏi việc triển khai. Các module chỉ giao tiếp thông qua các API của chúng và một module không cần biết về hoạt động bên trong của các module khác ra sao, một khái niệm được gọi là ẩn hoặc đóng gói thông tin (encapsulation). Do đó, chọn Access Modifier phải phù hợp để mỗi lớp hoặc thành viên không thể tiếp cận được từ bên ngoài.

Nếu phương thức của lớp con ghi đè phương thức của lớp cha, thì access modifier của phương thức trong lớp con không được phép thấp hơn access modifier của lớp cha. Điều này là để đảm bảo rằng các thực thể (instance) của lớp con có thể được sử dụng ở bất cứ nơi nào có thể sử dụng các thực thể của lớp cha, nghĩa là, để đảm bảo rằng Nguyên tắc thay thế Liskov (L trong SOLID) được thỏa mãn. 

Các thuộc tính không bao giờ được public, bởi vì làm như vậy sẽ mất quyền kiểm soát hành vi sửa đổi thuộc tính và khách hàng có thể sửa đổi nó theo ý muốn. Trong ví dụ dưới đây, AccessExample có thuộc tính id public. Nếu tại một thời điểm nào đó chúng ta muốn sử dụng int để lưu trữ thuộc tính id, thì chúng ta cần sửa đổi tất cả mã máy khách.

```java
public class AccessExample {
    public String id;
}
```

Thuộc tính public có thể được thay thế bằng getter và setter công khai để bạn có thể kiểm soát hành vi sửa đổi thuộc tính.

```java
public class AccessExample {

    private int id;

    public String getId() {
        return id + "";
    }

    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}
```

Nhưng vẫn có những trường hợp ngoại lệ, nếu đó là một lớp riêng cùng package hoặc lớp riêng lồng nhau, thì việc public các thuộc tính sẽ không có tác động gì lớn. 

```java
public class AccessWithInnerClassExample {
    private class InnerClass {
        int x;
    }

    private InnerClass innerClass;

    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }

    public int getValue() {
        return innerClass.x;  // direct access
    }
}
```

### Abstract Class and Interface

**1. Abstract class**

Cả hai abstract class và abstract method đều được khai báo bằng từ khóa **abstract**. Các abstract class thường chứa các abstract method và các abstract method phải được đặt trong các abstract class. 

Sự khác biệt lớn nhất giữa một lớp trừng tượng và một lớp bình thường là một lớp trừu tượng không thể được khởi tạo và để truy cập nó, cần phải kế thừa từ một lớp trừu tượng để khởi tạo các lớp con. 

```java
public abstract class AbstractClassExample {

    protected int x;
    private int y;

    public abstract void func1();

    public void func2() {
        System.out.println("func2");
    }
}
```

```java
public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

```java
// AbstractClassExample ac1 = new AbstractClassExample(); //'AbstractClassExample' is abstract; cannot be instantiated
AbstractClassExample ac2 = new AbstractExtendClassExample();
ac2.func1();
```

**2. Interface**

Interface là một phần mở rộng (extension) của một lớp trừu tượng, trước Java 8, nó có thể được coi là một lớp hoàn toàn trừu tượng, có nghĩa là nó không có bất kỳ phương thức nào có phần triển khai.

Từ Java 8, các interface cũng có thể có các triển khai phương thức mặc định, vì các interface không hỗ trợ các phương thức mặc định quá tốn chi phí để duy trì. Trước Java 8, nếu một interface muốn thêm các phương thức mới, tất cả các lớp triển khai interface đó phải được sửa đổi. 

Các thành viên của interface (thuộc tính + phương thức) mặc định là **public**  và không được phép xác định là private hoặc protected. 

Các thuộc tính của interface mặc định là **static** và **final**.

```java
public interface InterfaceExample {
    void func1();

    default void func2(){
        System.out.println("func2");
    }

    int x = 123;
    // int y;               // Variable 'y' might not have been initialized
    public int z = 0;       // Modifier 'public' is redundant for interface fields
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here
}

```

```java
public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

```java
// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
```

**3. So sánh**

- Từ quan điểm thiết kế, một abstract class cung cấp một mối quan hệ IS-A, vì vậy nó phải thỏa mãn nguyên tắc thay thế kiểu Liskov, nghĩa là, các đối tượng của lớp con phải có khả năng thay thế tất cả các đối tượng của lớp cha. interface giống như một mối quan hệ LIKE-A hơn, nó chỉ cung cấp một phương thức để thực hiện hợp đồng, và không yêu cầu interface và lớp triển khai interface phải có mối quan hệ IS-A.
- Về cách sử dụng, một lớp có thể triển khai nhiều interface, nhưng không thể kế thừa nhiều abstract class.
- Các thuộc tính của interface chỉ có thể thuộc kiểu static và kiểu final, trong khi các thuộc tính của abstract class không có hạn chế này.
- Các thành viên của một interface chỉ có thể là public, trong khi các thành viên của một abstract class có thể có nhiều access modifier.

**4. Lựa chọn sử dụng**

Sử dụng interface:
  - Cần phải làm cho các lớp không liên quan triển khai một phương thức, ví dụ, các lớp không liên quan có thể triển khai phương thức CompareTo() trong interface So sánh được.
  - Cần sử dụng đa kế thừa.

Sử dụng abstract class:
  - Cần chia sẻ mã giữa một số lớp liên quan.
  - Cần có khả năng kiểm soát access modifier của các thành viên kế thừa, không phải tất cả công khai.
  - Các thuộc tính non-static và non-final cần được kế thừa.

Trong nhiều trường hợp, các interface được ưu tiên hơn các abstract class vì các interface không có các yêu cầu phân cấp lớp nghiêm ngặt của các abstract class và cung cấp sự linh hoạt để thêm phương thức vào một lớp. Và bắt đầu từ Java 8, interface cũng có thể có phương thức thực thi mặc định, làm cho chi phí sửa đổi interface rất thấp.

[Hiểu rõ về abstract class và interface](https://www.ibm.com/developerworks/java/l-javainterface-abstract/)
[When to Use Abstract Class and Interface](https://dzone.com/articles/when-to-use-abstract-class-and-intreface)

### super

- Truy cập vào constructor của lớp cha: Bạn có thể sử dụng hàm super() để truy cập vào constructor của lớp cha, từ đó ủy thác cho lớp cha hoàn thành một số công việc khởi tạo.
- Truy cập các thành viên của lớp cha: Nếu một lớp con ghi đè việc triển khai một phương thức trong lớp cha, nó có thể sử dụng từ khóa super để tham chiếu đến việc triển khai phương thức của lớp cha. 

```java
public class SuperExample {
    protected int x;
    protected int y;

    public SuperExample(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void func() {
        System.out.println("SuperExample.func()");
    }
}
```

```java
public class SuperExtendExample extends SuperExample {
    private int z;

    public SuperExtendExample(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    public void func() {
        super.func();
        System.out.println("SuperExtendExample.func()");
    }
}
```

```java
SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();
```

```java
SuperExample.func()
SuperExtendExample.func()
```

[Using the Keyword super](https://docs.oracle.com/javase/tutorial/java/IandI/super.html)

### Override và Overload

**1. Override**

Tồn tại trong hệ thống kế thừa, có nghĩa là lớp con thực hiện định nghĩa và triển khai lại một phương thức hoàn toàn giống với khai báo phương thức của lớp cha. 

Để đáp ứng nguyên tắc thay thế Liskov, việc viết lại có hai ràng buộc sau:

  - Access modifier của phương thức lớp con phải lớn hơn hoặc bằng phương thức lớp cha.
  - Kiểu trả về của phương thức lớp con phải là kiểu trả về của phương thức lớp cha hoặc một kiểu con của nó. 

Sử dụng chú thích **@Override** cho phép trình biên dịch giúp kiểm tra xem hai ràng buộc trên có được đáp ứng hay không.

**2. Overload**

Tồn tại trong cùng một lớp có nghĩa là một phương thức có cùng tên với một phương thức hiện có, nhưng có ít nhất một kiểu tham số, số lượng và thứ tự khác nhau. 

Cần lưu ý rằng nếu giá trị trả về khác nhau và mọi thứ khác đều giống nhau thì nó không bị tính là overload. 

## Object class

### Tổng quan

Mặc định class Object là lớp cha của tất cả các class trong java. Tất cả các class được định nghĩa sẽ kế thừa các thành viên của class Object. Những phương thức sau cần chú ý:

```java
public final native Class<?> getClass()

public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException

protected void finalize() throws Throwable {}

```

### equals()

**1. Quan hệ tương đương**

(1) Tính phản xạ
```java
x.equals(x); // true
```

(2) Tính đối xứng

```java
x.equals(y) == y.equals(x); // true
```

(3) Tính bắc cầu

```java
if (x.equals(y) && y.equals(z))
    x.equals(z); // true;
```

(4) Tính nhất quán

Kết quả của việc gọi phương thức equals () nhiều lần không thay đổi
```
x.equals(y) == x.equals(y); // true
```

(5) So sánh với null

Gọi x.equals(null) trên bất kỳ đối tượng x nào không phải là null trả về false

```java
x.equals(null); // false;
```

**2. equals() với ==**

- Đối với các kiểu nguyên thủy, == xác định xem hai giá trị có bằng nhau hay không và các kiểu nguyên thủy không có phương thức equals().
- Đối với các kiểu tham chiếu, == xác định xem hai biến có tham chiếu đến cùng một đối tượng hay không, trong khi equals() xác định liệu các đối tượng được tham chiếu có tương đương hay không.

```java
Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false
```

**3. Ví dụ**

Thực hiện viết một class, Override phương thức equals() thoả mãn:
- Kiểm tra xem nó có phải là một tham chiếu đến cùng một đối tượng hay không, nếu có, trả về true.
- Kiểm tra xem nó có cùng kiểu không, nếu không, trả về false.
- Chuyển đổi đối tượng Object.
- Kiểm tra xem các thuộc tính có bằng nhau không.

```java
public class EqualExample {
    private int x;
    private int y;
    private int z;

    public EqualExample(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EqualExample that = (EqualExample) o;

        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}
```

### hashCode()

hashCode() trả về mã hash và equals() được sử dụng để xác định xem hai đối tượng có tương đương hay không. Hai đối tượng tương đương phải có cùng mã hash, nhưng hai đối tượng có cùng mã hash không nhất thiết phải tương đương. 

Khi override phương thức equals(), bạn phải luôn override phương thức hashCode() để đảm bảo rằng mã hash của hai đối tượng tương đương cũng bằng nhau. 

Trong đoạn mã dưới đây, hai đối tượng tương đương được tạo và thêm vào HashSet. Chúng tôi muốn coi hai đối tượng này giống nhau và chỉ thêm một đối tượng vào set, nhưng vì EqualExample không triển khai phương thức hashCode(), mã hash của hai đối tượng khác nhau, điều này cuối cùng khiến set thêm hai đối tượng. 

```java
EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet<EqualExample> set = new HashSet<>();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
```

Hash function lý tưởng phải có tính đồng nhất, nghĩa là, các đối tượng không bằng nhau phải được phân bố đồng đều trên miền giá trị hash code. Điều này yêu cầu hash function phải tính đến giá trị của tất cả các thuộc tính và mỗi thuộc tính có thể được coi là một chữ số nhất định trong hệ cơ số R, sau đó tạo thành một số nguyên hệ R. R thường là một số nguyên tố để tránh việc va chạm. Trong trường hợp EqualExample ta lấy R = 31.

Phép nhân một số với 31 có thể được chuyển đổi thành dịch trái bit và trừ: **31 * x == (x << 5) - x** và trình biên dịch thực hiện việc tối ưu hóa này một cách tự động. 

```java
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}  
```

### toString()

Theo mặc định, ToStringExample@4554617c được trả về, trong đó giá trị sau dấu @ là biểu diễn thập lục phân không dấu của hashcode. 


```java
public class ToStringExample {
    private int number;

    public ToStringExample(int number) {
        this.number = number;
    }
}
```
```java
ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());
```

```bash
ToStringExample@4554617c
```

### clone()

**1. cloneable**

clone() là một phương thức protected của class Object, nó không public. Nếu một lớp không override rõ ràng clone(), các lớp khác không thể gọi trực tiếp phương thức clone() từ một instance của lớp này.

```java
public class CloneExample {
    private int a;
    private int b;
}
```
```java
CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'
```

Override clone() để thực hiện các bước sau:

```java
public class CloneExample {
    private int a;
    private int b;

    @Override
    protected CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
```
```java
CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
```
```sh
java.lang.CloneNotSupportedException: CloneExample
```

Ở trên throw CloneNotSupportedException vì CloneExample không implements interface Cloneable.

Cần lưu ý rằng phương thức clone() không phải là một phương thức của interface Cloneable, mà là một phương thức protected của Object. Interface Cloneable chỉ quy định rằng nếu một lớp không implements interface Cloneable mà gọi phương thức clone(), thì một CloneNotSupportedException sẽ được throw. 

```java
public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

**2. Shallow Copy**

Object được sao chép và object gốc tham chiếu đến cùng một object, tức không tạo ra object mới.

```java
public class ShallowCloneExample implements Cloneable {
    private int[] arr;

    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}
```
```java
ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 222
```

**3. Deep Copy**

Object được sao chép và object gốc tham chiếu đến các object khác nhau, tức tạo ra một object mới y hệt object cũ.

```java
public class DeepCloneExample implements Cloneable {
    private int[] arr;

    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone();
        result.arr = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;
    }
}
```
```java
DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
```

**4. Thay thế clone()**

Sử dụng clone() để sao chép một object rất phức tạp và rủi ro, tạo ra các ngoại lệ và yêu cầu chuyển đổi kiểu. Theo cuốn Effective Java, tốt nhất là không sử dụng clone(), bạn có thể sử dụng constructor để sao chép một object.


```java
public class CloneConstructorExample {
    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i < original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
```
```java
CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
```

## Keywords

### final

1. Attribute

Khai báo thuộc tính dưới dạng hằng số (constants), hằng số thời chưa được gán giá trị hoặc hằng số không thể thay đổi sau khi được khởi tạo trong thời gian chạy. 
   - Đối với các loại nguyên thủy, final làm cho giá trị không thay đổi.
   - Đối với các loại tham chiếu, final làm cho tham chiếu không thay đổi, vì vậy nó không thể tham chiếu đến các đối tượng khác, nhưng bản thân đối tượng được tham chiếu có thể được sửa đổi.

```
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
```

2. Method

Các phương thức đã khai báo final không thể bị override bởi các lớp con.

Các phương thức private được chỉ định ngầm là final. Nếu một phương thức được định nghĩa trong lớp con có cùng tên với phương thức private trong lớp cha, thì phương thức của lớp con không ghi đè phương thức của lớp cha mà định nghĩa nó trong lớp con là một phương thức mới. 

3. Class

Các lớp đã khai báo final không được phép kế thừa.

### static

**1. Static Variable**

- **Static variable**: Còn được gọi là biến của lớp, có nghĩa là biến này thuộc về một lớp và tất cả các instance của lớp đều dùng chung một biến tĩnh, có thể được truy cập trực tiếp thông qua tên lớp. Chỉ có một biến tĩnh tồn tại trong bộ nhớ. 

- **Instance variable**: Mỗi khi một instance được tạo, instance variable được tạo và sống chết theo biến đó.

```java
public class A {
    private int x;         // instance variable
    private static int y;  // static variable

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
```

**2. Static method**

Static method tồn tại khi lớp được khởi tạo, nó không phụ thuộc vào bất kỳ instance nào. Vì vậy, một phương thức tĩnh phải có phần triển khai, có nghĩa là nó không thể là abstract method.

```java
public class A {
    private static int x;
    private int y;

    public static void func1(){
        int a = x;
        // int b = y;  // Non-static field 'y' cannot be referenced from a static context
        // int b = this.y;     // 'A.this' cannot be referenced from a static context
    }
}
```

**3. Static Scope**

Các khối câu lệnh tĩnh được chạy một lần khi lớp được khởi tạo.

```java
public class A {
    static {
        System.out.println("123");
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}
```
```sh
123
```

**4. Static Inner Class**

Một lớp bên trong non-static phụ thuộc vào một instance của lớp bên ngoài, trong khi một lớp bên trong static thì không.

```java
public class OuterClass {
    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
```

Một lớp bên trong static không thể truy cập các biến và phương thức non-static của lớp bên ngoài.

**5. Static Package**

Không cần chỉ định ClassName khi sử dụng các biến và phương thức tĩnh, điều này giúp đơn giản hóa code, nhưng làm giảm đáng kể khả năng đọc hiểu code. 

```java
import static com.xxx.ClassName.*
```

**6. Trình tự khởi tạo**

static variable và static scope được ưu tiên hơn các instance variable và scope bình thường. Thứ tự khởi tạo của các static variable và static scope phụ thuộc vào thứ tự của chúng trong code.

```java
public static String staticField = "static variable";
```

```java
static {
    System.out.println("static Scope");
}
```

```java
public String field = "instance variable";
```

```java
{
    System.out.println("normal scope");
}
```

Cuối cùng là constructor.

```java
public InitialOrderTest() {
    System.out.println("constructor");
}
```

Khi có sự kế thừa, trình tự khởi tạo là:

- Lớp cha (static variable, static scope)
- Các lớp con (static variable, static scope)
- Lớp cha (instance variable, normal scope)
- Lớp cha (constructor)
- Các lớp con (instance variable, normal scope)
- Lớp con (constructor)

## Reflection

Mỗi lớp có một Class object chứa thông tin về lớp. Khi biên dịch một lớp mới, một tệp .class có cùng tên sẽ được tạo và nội dung của tệp này chứa đối tượng Class. 

Tải lớp tương đương với một Class object. Các lớp được tự động tải vào JVM khi chúng được sử dụng lần đầu tiên. Bạn có thể sử dụng <code>Class.forName("com.mysql.jdbc.Driver")</code> để kiểm soát việc tải lớp. Phương thức này trả về một Class object.

Java Reflecion cho phép bạn truy cập, sửa đổi cấu trúc và hành vi của một đối tượng tại thời gian chạy (runtime) của chương trình. Đồng thời nó cho phép bạn truy cập vào các thành viên private (private member) tại mọi nơi trong ứng dụng, điều này không được phép với cách tiếp cận truyền thống.

**Class** và **java.lang.reflect** cung cấp hỗ trợ cho reflection. Thư viện java.lang.reflect bao gồm 3 class:
- Field: Bạn có thể sử dụng các phương thức get() và set() để truy cập và chỉnh sửa các trường được liên kết với Field object;
- Method: Phương thức được liên kết với Method object có thể được gọi bằng phương thức invoke()
- Constructor: Constructor có thể được sử dụng để tạo các object mới

Advantages of Using Reflection: 
- Extensibility Features: An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names
- Class Browsers and Visual Development Environments: A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code
- Debuggers and Test Tools :Debuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite.

**Drawbacks of Reflection:**

Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection. 
- Performance Overhead  : Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications. 
- Security Restrictions  : Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet. 
- Exposure of Internals  :Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.

Đọc thêm: [Java Basic - Reflection](/pages/d99473/)

## Exception

Throwable có thể được sử dụng để đại diện cho bất kỳ lớp nào có thể được throw như một exception, được chia thành hai loại: **Error** và **Exception** . Trong đó, Error được sử dụng để biểu thị lỗi mà JVM không thể xử lý. Exception được chia thành hai loại:

- **Checked Exceptions** : Là một ngoại lệ được kiểm tra và thông báo bởi trình biên dịch tại thời điểm biên dịch, chúng cũng có thể được gọi là ngoại lệ thời gian biên dịch (Compile-time Exceptions). Và lập trình viên không thể lường trước.
- **Unchecked Exceptions** : Là một ngoại lệ không được kiểm tra trong quá trình biên dịch. Chúng cũng được gọi là ngoại lệ thời gian chạy (Runtime Exceptions). Là ngoại lệ có thể tránh được bởi lập trình viên. Unchecked Exceptions kế thừa từ Runtime Exception.

![](/img/java/exception.png)

Đọc thêm: [Java Basic - Exception](/pages/739680/)

## Generics

```java
public class Box<T> {
    // T stands for "Type"
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }

```

Đọc thêm: [Java Basic - Generic](/pages/b0770a/)

## Annotation

Annotation trong Java là một số siêu thông tin được đính kèm với mã, được sử dụng để phân tích cú pháp và sử dụng bởi một số công cụ trong quá trình biên dịch và thời gian chạy, đồng thời có các chức năng mô tả và cấu hình. Annotation không và không thể ảnh hưởng đến logic thực tế của mã, mà chỉ đóng vai trò hỗ trợ. 

Đọc thêm: [Java Basic - Annotation](/pages/bd36d6/)

## Đặc điểm của Java

### Có gì mới trong các phiên bản Java

**New highlights in Java SE 8** 
1. Lambda Expressions 
2. Pipelines and Streams 
3. Date and Time API 
4. Default Methods 
5. Type Annotations 
6. Nashhorn JavaScript Engine 
7. Concurrent Accumulators 
8. Parallel operations 
9. PermGen Error Removed New 

highlights in Java SE 7 
1. Strings in Switch Statement 
2. Type Inference for Generic Instance Creation 
3. Multiple Exception Handling 
4. Support for Dynamic Languages 
5. Try with Resources 
6. Java nio Package 
7. Binary Literals, Underscore in literals 
8. Diamond Syntax

[Difference between Java 1.8 and Java 1.7?
](http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17)

### Sự khác biệt giữ Java và C++

- Java là một ngôn ngữ hướng đối tượng thuần túy, tất cả các đối tượng kế thừa từ java.lang.Object còn C++ hỗ trợ cả hướng đối tượng và hướng thủ tục. 
- Java đạt được các tính năng đa nền tảng thông qua máy ảo Java, nhưng C++ là dành riêng cho nền tảng.
- Java không có con trỏ, các tham chiếu của nó có thể được hiểu là con trỏ an toàn còn C++ có con trỏ giống như C. 
- Java hỗ trợ thu gom rác tự động, trong khi C++ yêu cầu thu thập thủ công.
- Java không hỗ trợ đa kế thừa, bạn chỉ có thể đạt được mục đích tương tự bằng cách implements nhiều interface, trong khi C++ hỗ trợ đa kế thừa. 
- Java không hỗ trợ overload toán tử Mặc dù nó có thể hỗ trợ các phép toán cộng trên hai đối tượng String, nhưng đây là một phép toán được tích hợp sẵn trong ngôn ngữ và không thuộc về overload toán tử, trong khi C++ thì có thể. 
- Goto của Java là một từ dành riêng, nhưng không có sẵn, C++ có thể sử dụng goto.
- Java không hỗ trợ biên dịch có điều kiện còn C++ thực hiện biên dịch có điều kiện thông qua các lệnh tiền xử lý như #ifdef #ifndef. 

[What are the main differences between Java and C++?](https://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php)

### JRE với JDK

- JRE là chương trình JVM, ứng dụng Java cần chạy trên JRE.
- JDK là một tập hợp các công cụ JRE, JRE + công cụ phát triển các chương trình java. ví dụ: nó cung cấp trình biên dịch "javac" 


## Tham khảo
- [https://www.pdai.tech/](https://www.pdai.tech/)
